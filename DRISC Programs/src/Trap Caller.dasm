.define keyboard_address 0x00ffffff
.define terminal_address 0x1100000
	nop
	li a3 keyboard_address
:loop
	lb a5 a3 0 //load mcause
	blt a5 zero :loop //if there is no input the value will be negative 	
	
	li t0 terminal_address
	sb zero t0 1
	
	li t0 11
	
	dec a5 48
	blt a5 t0 :c	
	dec a5 39
:c

	li a4 11 //load biggest option
	
	bgtu a5 a4 :CAUSE_UNKNOWN //if mcause > biggest option
	
	slli a4 a5 2 //adjust option number to word addresses.
	la a5 :switch_table //load the table address
	add a5 a5 a4 //add option offset to the table address
	
	lw a5 a5 0 //load address from table
	jr a5 //jump to loaded address
	
:switch_table
    .word :CAUSE_INSTRUCTION_ADDRESS_MISALIGNED
    .word :CAUSE_UNKNOWN
    .word :CAUSE_ILLEGAL_INSTRUCTION
    .word :CAUSE_BREAKPOINT
    .word :CAUSE_LOAD_ADDRESS_MISALIGNED
    .word :CAUSE_UNKNOWN
    .word :CAUSE_STORE_ADDRESS_MISALIGNED
    .word :CAUSE_UNKNOWN
    .word :CAUSE_ECALL_FROM_USER_MODE
    .word :CAUSE_UNKNOWN
    .word :CAUSE_UNKNOWN
    .word :CAUSE_ECALL_FROM_MACHINE_MODE
	
:CAUSE_UNKNOWN //unknown causes are impossible to happen without manually setting it up
	li t0 1 
	csrw mcause t0 //mcause = 1
	la t0 :switch_end
	csrw mepc t0
	li t0 0x80000000 // trap handler address;
	jr t0 0
	
:CAUSE_INSTRUCTION_ADDRESS_MISALIGNED
	j 2 //will try to jump to address 1 which is misaligned for instructions
	jump :switch_end
	
:CAUSE_ILLEGAL_INSTRUCTION
	.word 0 // 0x00000000 instruction does not exist and it is illegal
	jump :switch_end
	
:CAUSE_BREAKPOINT
	ebreak //ebreak triggers a breakpoint
	jump :switch_end
	
:CAUSE_LOAD_ADDRESS_MISALIGNED
	lw t0 zero 2 //tries to load a word from address 1 which is word-misaligned
	jump :switch_end
	
:CAUSE_STORE_ADDRESS_MISALIGNED
	sw t0 zero 2 //tries to store a word from address 1 which is word-misaligned
	jump :switch_end
	
:CAUSE_ECALL_FROM_USER_MODE
	//to call from user mode we need to call mret since the processor starts at machine mode
	la t0 :CAUSE_ECALL_FROM_MACHINE_MODE
	csrw mepc t0
	mret	
:CAUSE_ECALL_FROM_MACHINE_MODE
	ecall
:switch_end
	
	j :loop

	